{"version":3,"file":"services.js","sources":["../../src/utils/services.ts"],"sourcesContent":["/* tslint:disable */\nconst mappingDayPeriod: any = {\n  MONDAY: 1,\n  TUESDAY: 2,\n  WEDNESDAY: 3,\n  THURSDAY: 4,\n  FRIDAY: 5,\n  SATURDAY: 6,\n  SUNDAY: 7,\n};\n\nconst mappingMonthPeriod: any = {\n  FIRST: 1,\n  SECOND: 2,\n  THIRD: 3,\n  FOURTH: 4,\n  FIFTH: 5,\n  LAST: 6,\n};\n\nconst swap = (json: any) => {\n  const ret: any = {};\n  for (const key in json) {\n    ret[json[key]] = key;\n  }\n  return ret;\n}\n\n// * Shared functions\nconst parseTimeStrToNormalTime = (timeStr: string) => {\n  const [hourMin, temp] = timeStr.split(' ');\n  const bonus = temp === 'PM' ? 12 : 0;\n  const [defaultHour, min] = hourMin.split(':');\n\n  let hour = defaultHour === '12' ? '0' : defaultHour;\n  return `${+hour + bonus}:${+min}`;\n}\n\nconst getWeeksStartAndEndInMonth = (year: number, month: number) => {\n  const dayStart = 'monday'; // * Start by monday\n  \n  let weeks = [],\n      firstDate = new Date(year, month, 1),\n      lastDate = new Date(year, month + 1, 0),\n      numDays = lastDate.getDate();\n\n  let start = 1;\n  let end = 7 - firstDate.getDay();\n  if (dayStart === 'monday') {\n      if (firstDate.getDay() === 0) {\n          end = 1;\n      } else {\n          end = 7 - firstDate.getDay() + 1;\n      }\n  }\n\n  while (start <= numDays) {\n      weeks.push({start: start, end: end});\n      start = end + 1;\n      end = end + 7;\n      end = start === 1 && end === 8 ? 1 : end;\n      if (end > numDays) {\n          end = numDays;\n      }\n  }\n\n  return weeks;\n}\n\nconst getTotalWeeksInMonth = (year: number, month: number) => {\n  return (getWeeksStartAndEndInMonth(year, month) || []).length;\n};\n\nconst getCurrentWeekIndex = (theDate: Date) => {\n  const date = new Date(theDate);\n  const currentDate = date.getDate();\n  return (getWeeksStartAndEndInMonth(date.getFullYear(), date.getMonth())).findIndex(item => item.start >= currentDate && currentDate <= item.end);\n};\n\n// * ------------- END SHARED FUNCTIONS\nconst getOpenService = (openSchedules = [] as any, targetDate: any) => {\n  const fullSchedules = openSchedules.filter((schedule: any) => schedule.type === 'FULL_DAY');\n  const weeklySchedules = openSchedules.filter((schedule: any) => schedule.type === 'WEEKLY');\n  const monthlySchedules = openSchedules.filter((schedule: any) => schedule.type === 'MONTHLY');\n  const dateRangeSchedules = openSchedules.filter((schedule: any) => schedule.type === 'DATE_RANGE');\n\n  const getOpenFullDay = () => {\n    return fullSchedules[0];\n  };\n\n  const getOpenWeekly = () => {\n    return weeklySchedules.find((date: any) => {\n      const startDate = new Date(date.startTime);\n      const endDate = new Date(date.endTime);\n      return (targetDate > startDate) && (targetDate < endDate);\n    });\n  };\n\n  const getOpenMonthly = () => {\n    const currentDateTime = new Date();\n    const totalWeekInMonth = getTotalWeeksInMonth(currentDateTime.getFullYear(), currentDateTime.getMonth());\n    const weekIndex = getCurrentWeekIndex(currentDateTime);\n    const swapMappingMonthlyPeriod = swap(mappingMonthPeriod);\n\n    // filter the \n    return monthlySchedules.filter((date: any) => {\n      if (weekIndex === totalWeekInMonth) {\n        return (date.period === swapMappingMonthlyPeriod[weekIndex]) || (date.period === swapMappingMonthlyPeriod[6]); // * 6 is LAST\n      }\n\n      // console.log(date.period, swapMappingMonthlyPeriod[weekIndex]);\n\n      return date.period === swapMappingMonthlyPeriod[weekIndex];\n    }).find((date: any) => {\n      const currentDayIndex = (new Date()).getDay() || 7;\n      const startDate = new Date(date.startTime);\n      const endDate = new Date(date.endTime);\n      return currentDayIndex === mappingDayPeriod[date.day] && (targetDate > startDate) && (targetDate < endDate);\n    });\n  };\n\n  const getOpenDateRange = () => {\n    return dateRangeSchedules.find((date: any) => {\n      const startDate = new Date(date.startTime);\n      const endDate = new Date(date.endTime);\n      return (targetDate > startDate) && (targetDate < endDate);\n    });\n  };\n\n  // * FOr weekly\n  const isOpen = getOpenFullDay() || getOpenDateRange() || getOpenWeekly() || getOpenMonthly();\n  // const isOpen = getOpenDateRange();\n\n  return isOpen;\n};\n\nconst getNextOpenSchedule = (openSchedules = [] as any, targetDate: any) => {\n  if (openSchedules.length === 1 && openSchedules[0].type === 'WEEKLY') {\n    return openSchedules[0];\n  }\n\n  const weeklySchedules = openSchedules.filter((schedule: any) => schedule.type === 'WEEKLY');\n  const monthlySchedules = openSchedules.filter((schedule: any) => schedule.type === 'MONTHLY');\n\n  const sortByStartDate = (schedules: any) => {\n    return schedules.sort((obj1: any, obj2: any) => {\n      const objDate1: any = new Date(obj1.startTime);\n      const objDate2: any = new Date(obj2.startTime);\n      return objDate1 - objDate2;\n    });\n  }\n\n  const getNextOpenWeeklySchedule = () => {\n    // * Sort by start Date\n    const sortSchedules = sortByStartDate(weeklySchedules);\n\n    return sortSchedules.find((date: any) => {\n      const startDate = new Date(date.startTime);\n\n      return startDate > targetDate;\n    });\n  }\n\n  const getNextOpenMonthlySchedule = () => {\n    const sortSchedules = sortByStartDate(monthlySchedules);\n\n    return sortSchedules.find((date: any) => {\n      const startDate = new Date(date.startTime);\n      return startDate > targetDate;\n    });\n    // const transform = monthlySchedules.map();\n  };\n\n  const bestNextSchedules = sortByStartDate([\n    getNextOpenWeeklySchedule(),\n    getNextOpenMonthlySchedule(),\n  ])\n\n  return bestNextSchedules[0];\n};\n\nconst groupBy = (items: any, key: any) => items.reduce(\n  (result: any, item: any) => ({\n    ...result,\n    [item[key]]: [\n      ...(result[item[key]] || []),\n      item,\n    ],\n  }),\n  {},\n);\n\nconst transformOpenSchedule = (schedules = [] as any) => {\n  const fullDaySchedules = schedules.filter((schedule: any) => schedule.type === 'FULL_DAY');\n  const weeklySchedules = schedules.filter((schedule: any) => schedule.type === 'WEEKLY');\n  const monthlySchedules = schedules.filter((schedule: any) => schedule.type === 'MONTHLY');\n  const dateRangeSchedules = schedules.filter((schedule: any) => schedule.type === 'DATE_RANGE');\n\n  const weeklySchedulesGroupByDayObj = groupBy(weeklySchedules, 'day');\n\n  // * Check & merge object if some start date have the end Time at 59 and next time at 00\n  const newWeeklyObj: any = {};\n  for (const day in weeklySchedulesGroupByDayObj) {\n    if (!newWeeklyObj[day]) {\n      newWeeklyObj[day] = [];\n    }\n\n    let isMerge = false;\n    for (const index in weeklySchedulesGroupByDayObj[day]) {\n      const scheduleInDay = weeklySchedulesGroupByDayObj[day][index];\n\n      if (isMerge) { // * Skip the rest if we had 1 case for merge\n        continue;\n      }\n\n      const scheduleDateTime = new Date(scheduleInDay.endTime);\n      const endTimeAtHour = scheduleDateTime.getHours();\n      const endTimeAtMin = scheduleDateTime.getMinutes();\n      if (endTimeAtHour === 23 && endTimeAtMin === 59) {\n        // * Do things here\n        const nextOpenTimeInDay = weeklySchedulesGroupByDayObj[day][index + 1];\n\n        if (nextOpenTimeInDay) {\n          const nextScheduleOpenDateTime = new Date(nextOpenTimeInDay.startTime);\n          const nextStartTimeAtHour = nextScheduleOpenDateTime.getHours();\n          const nextStartTimeAtMin = nextScheduleOpenDateTime.getMinutes();\n\n          if (nextStartTimeAtHour === 0 && nextStartTimeAtMin === 0) {\n            // * Merge here\n            isMerge = true;\n\n            const newEndTime = new Date(nextOpenTimeInDay.endTime);\n\n            newWeeklyObj[day].push({\n              ...scheduleInDay,\n              endTime: new Date(newEndTime.setDate(newEndTime.getDate() + 1)),\n            });\n\n            continue;\n          }\n        }\n      }\n      newWeeklyObj[day].push(scheduleInDay);\n    }\n  }\n\n  const transformWeekly = Object.keys(newWeeklyObj).reduce((list: any, dateKey: any) => {\n    for (const date of newWeeklyObj[dateKey]) {\n      list.push(date);\n    }\n\n    return list;\n  }, []);\n\n  return [\n    ...fullDaySchedules,\n    ...transformWeekly,\n    ...monthlySchedules,\n    ...dateRangeSchedules,\n  ];\n};\n\nconst convertHourToDateTime = (schedules = []) => {\n  const weeklySchedules = schedules.filter((schedule: any) => schedule.type === 'WEEKLY');\n  const monthlySchedules = schedules.filter((schedule: any) => schedule.type === 'MONTHLY');\n  const dateRangeSchedules = schedules.filter((schedule: any) => schedule.type === 'DATE_RANGE');\n\n  const currentDateTime = new Date();\n  const currentDayIndex = currentDateTime.getDay() || 7; // * if SUNDAY -> 7\n  const weekIndex = getCurrentWeekIndex(currentDateTime);\n\n  const convertForWeekly = (time: string, day: string) => {\n    const [hour, min] = time.split(':');\n    const targetDate = new Date();\n\n    targetDate.setHours(+hour);\n    targetDate.setMinutes(+min);\n\n    if (currentDayIndex > mappingDayPeriod[day]) {\n      const diffDay = 7 - currentDayIndex;\n      targetDate.setDate(targetDate.getDate() + diffDay + mappingDayPeriod[day]);\n    } else if (mappingDayPeriod[day] > currentDayIndex) {\n      const diffDay = mappingDayPeriod[day] - currentDayIndex;\n      targetDate.setDate(targetDate.getDate() + diffDay);\n    }\n\n    return targetDate;\n  };\n\n  const convertForMonthly = (period: string, time: string, day: string) => {\n    const [hour, min] = time.split(':');\n    const targetDate = new Date();\n\n    targetDate.setHours(+hour);\n    targetDate.setMinutes(+min);\n\n    if (mappingMonthPeriod[period] === weekIndex) {\n      if (currentDayIndex > mappingDayPeriod[day]) {\n        const diffDay = 7 - currentDayIndex;\n\n        targetDate.setDate(targetDate.getDate() + diffDay + mappingDayPeriod[day]);\n      } else if (mappingDayPeriod[day] > currentDayIndex) {\n        const diffDay = mappingDayPeriod[day] - currentDayIndex;\n        targetDate.setDate(targetDate.getDate() + diffDay);\n      }\n    } else if (mappingMonthPeriod[period] > weekIndex) {\n      const diffDay = 7 - currentDayIndex;\n      const diffWeek = mappingMonthPeriod[period] - weekIndex;\n      const totalDiffDay = diffDay + (diffWeek * mappingDayPeriod[day]);\n\n      targetDate.setDate(targetDate.getDate() + totalDiffDay);\n    } else if (weekIndex > mappingMonthPeriod[period]) {\n      targetDate.setMonth(targetDate.getMonth() + 1);\n      targetDate.setDate(1);\n\n      const diffWeeks = mappingMonthPeriod[period] - 1;\n      targetDate.setDate(targetDate.getDate() + ((diffWeeks * 7) * mappingDayPeriod[day]));\n    };\n\n    return targetDate;\n  };\n\n  const transformWeekly = weeklySchedules.map((schedule: any) => {\n    return {\n      ...schedule,\n      startTime: convertForWeekly(schedule.startTime, schedule.day),\n      endTime: convertForWeekly(schedule.endTime, schedule.day),\n    }\n  });\n\n  const transformMonthly = monthlySchedules.map((schedule: any) => {\n    return {\n      ...schedule,\n      startTime: convertForMonthly(schedule.period, schedule.startTime, schedule.day),\n      endTime: convertForMonthly(schedule.period, schedule.endTime, schedule.day),\n    }\n  });\n\n  const transformDateRange = dateRangeSchedules.map((schedule: any) => {\n    const startTime = new Date(schedule.startDate);\n    const endTime = new Date(schedule.endDate);\n\n    const [startHour = 0, startMin = 0] = schedule.startTime.split(':');\n    const [endHour = 0, endMin = 0] = schedule.endTime.split(':');\n\n    startTime.setHours(+startHour);\n    startTime.setMinutes(+startMin);\n\n    endTime.setHours(+endHour);\n    endTime.setMinutes(+endMin);\n\n    return {\n      ...schedule,\n      startTime,\n      endTime,\n    };\n  });\n\n  return [\n    ...transformWeekly,\n    ...transformMonthly,\n    ...transformDateRange,\n  ];\n}\n\nconst transformScheduleDateTime = (schedules = [] as any) => {\n  const normalSchedules = schedules.map((date: any) => {\n    return {\n      ...date,\n      startTime: date.startTime ? parseTimeStrToNormalTime(date.startTime) : undefined,\n      endTime: date.endTime ? parseTimeStrToNormalTime(date.endTime) : undefined,\n    };\n  });\n\n  const convertSchedules: any = convertHourToDateTime(normalSchedules);\n\n  const transformSchedules = transformOpenSchedule(convertSchedules);\n  return transformSchedules;\n}\n\nconst mergeOpenAndClosedSchedule = (openSchedule = {} as any, closedSchedule = {} as any) => {\n  const currentDateTime = new Date();\n\n  if (openSchedule.startTime >= closedSchedule.startTime && closedSchedule.endTime >= openSchedule.endTime) {\n    return {\n      openSchedule: {},\n      closedSchedule: {},\n    };\n  }\n\n  if (closedSchedule.startTime > openSchedule.startTime && openSchedule.endTime > closedSchedule.endTime) {\n    return {\n      openSchedule: {\n        ...openSchedule,\n        endTime: closedSchedule.startTime,\n      },\n      closedSchedule,\n    };\n  }\n\n  if (closedSchedule.startTime >= openSchedule.startTime && openSchedule.endTime > closedSchedule.endTime) {\n    const newStartTime = closedSchedule.endTime;\n    if (newStartTime > currentDateTime) {\n      return {\n        openSchedule: {},\n        closedSchedule,\n        nextOpenSchedule: {\n          ...openSchedule,\n          startTime: newStartTime,\n        },\n      };\n    }\n\n    return {\n      openSchedule: {\n        ...openSchedule,\n        startTime: newStartTime,\n      },\n      closedSchedule,\n    };\n  }\n\n  if (openSchedule.startTime >= closedSchedule.startTime && closedSchedule.endTime > openSchedule.endTime) {\n    return {\n      openSchedule: {\n        ...openSchedule,\n        endTime: closedSchedule.startTime,\n      },\n      closedSchedule,\n    };\n  }\n\n  if (closedSchedule.startTime >= openSchedule.startTime && closedSchedule.endTime >= openSchedule.endTime) {\n    return {\n      openSchedule: {},\n      closedSchedule: {},\n    };\n  }\n\n  return {\n    openSchedule,\n    closedSchedule,\n  };\n};\n\nconst calculateTimeOpenCloseService = (openSchedules = [], closedSchedules = [], targetDate = new Date()) => {\n  // console.log('@targetDate', targetDate);\n  const transformOpenSchedules = transformScheduleDateTime(openSchedules);\n  const transformClosedSchedules = transformScheduleDateTime(closedSchedules);\n\n  const openSchedule = getOpenService(transformOpenSchedules, targetDate);\n  const closedSchedule = getOpenService(transformClosedSchedules, targetDate);\n  const nextOpenSchedule = getNextOpenSchedule(transformOpenSchedules, targetDate);\n\n\n  if (openSchedule && closedSchedule) {\n    return {\n      nextOpenSchedule,\n      ...mergeOpenAndClosedSchedule(openSchedule, closedSchedule),\n    }\n  }\n\n  return {\n    openSchedule,\n    closedSchedule,\n    nextOpenSchedule,\n  }\n};\n\nexport {\n  parseTimeStrToNormalTime,\n  getTotalWeeksInMonth,\n  getCurrentWeekIndex,\n  calculateTimeOpenCloseService,\n};"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}